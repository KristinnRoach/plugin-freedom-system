# DSP Architecture: SimpleSampler

**CRITICAL CONTRACT:** This specification is immutable during Stages 1-4 implementation. Stage 1 Planning cannot proceed without this file. Stage 3 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research
**Generated date:** 2025-12-18
**Referenced by:** Stage 1 (Planning), Stage 3 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Sample Playback Engine

- **JUCE Classes:** `juce::Synthesiser`, `juce::SynthesiserVoice`, `juce::SynthesiserSound`
- **Purpose:** Polyphonic sample playback with MIDI triggering across full keyboard range (C-2 to G8, MIDI 0-127)
- **Parameters Affected:** `volume`, `tuning`
- **Configuration:**
  - 16 voices maximum (polyphonic playback)
  - Voice stealing: Oldest-first algorithm when all 16 voices active
  - Root note: C3 (MIDI note 60) plays sample at original pitch (1.0x playback rate)
  - One-shot playback (no looping in POC)
  - Sample buffer: Single `juce::AudioBuffer<float>` loaded in memory

### Voice Management System

- **JUCE Class:** `juce::Synthesiser` (built-in voice allocation)
- **Purpose:** Manage 16 simultaneous voices with polyphonic note triggering
- **Configuration:**
  - Fixed 16-voice array (no dynamic allocation in audio thread)
  - Voice allocation: O(1) scan for free voice
  - Voice stealing: When all 16 voices active, steal oldest voice (lowest startTime)
  - Voice lifecycle: IDLE → ACTIVE (note-on) → RELEASING (note-off) → IDLE
  - Each voice tracks: sample playback position, MIDI note, velocity, tuning offset

### Pitch-Shifting Engine

- **JUCE Class:** Custom implementation using playback rate adjustment
- **Purpose:** Transpose sample playback across MIDI keyboard range with tuning offset
- **Parameters Affected:** MIDI note number, `tuning`
- **Configuration:**
  - Root note: C3 (MIDI 60) = 1.0x playback rate
  - Pitch calculation: `semitoneOffset = (midiNote - 60) + tuningParameter`
  - Playback rate: `playbackRate = pow(2.0, semitoneOffset / 12.0)`
  - Example: MIDI 72 (C4) + tuning 0.0 = 12 semitones → 2.0x playback rate (1 octave up)
  - Example: MIDI 60 (C3) + tuning -12.0 = -12 semitones → 0.5x playback rate (1 octave down)

### Sample Interpolation

- **JUCE Class:** Custom linear interpolation (POC simplicity)
- **Purpose:** Read fractional sample positions during pitch-shifted playback
- **Configuration:**
  - Method: Linear interpolation between adjacent samples
  - Formula: `output = sample[floor(pos)] * (1 - frac) + sample[ceil(pos)] * frac`
  - Trade-off: Fast but lower quality (acceptable for POC)
  - Future upgrade: Lagrange or sinc interpolation for better quality

### Velocity-Sensitive Volume

- **JUCE Class:** Custom gain calculation
- **Purpose:** Scale playback volume based on MIDI velocity and volume parameter
- **Parameters Affected:** `volume`, MIDI velocity
- **Configuration:**
  - Formula: `finalGain = volumeParameter * (midiVelocity / 127.0)`
  - volumeParameter: 0.0-1.0 (normalized linear)
  - midiVelocity: 0-127 (MIDI standard)
  - Applied per-voice during sample rendering

---

## Processing Chain

```
MIDI Input (from DAW or computer keyboard)
  ↓
MIDI Note-On Detection (processBlock MIDI iteration)
  ↓
Voice Allocation (Synthesiser::noteOn)
  ├─ Find free voice (IDLE state) OR
  └─ Steal oldest voice (all 16 active)
  ↓
Voice Initialization
  ├─ Calculate pitch: semitoneOffset = (midiNote - 60) + tuning
  ├─ Calculate playback rate: pow(2.0, semitoneOffset / 12.0)
  ├─ Calculate gain: volume * (velocity / 127.0)
  └─ Reset playback position to 0
  ↓
Sample Rendering (per voice, per buffer)
  ├─ Read sample with linear interpolation
  ├─ Apply gain (velocity × volume)
  └─ Advance playback position by playback rate
  ↓
Voice Mixing (all 16 voices summed)
  ↓
Stereo Output (channels 0-1)
  ↓
MIDI Note-Off Detection
  ↓
Voice Release
  └─ Mark voice as IDLE (immediate stop, no envelope in POC)
```

**Routing notes:**
- No parallel processing (sequential voice rendering)
- No feedback loops
- No sidechain inputs
- All 16 voices render to same stereo output buffer (mixed)

---

## System Architecture

### File I/O System

**File types supported:** WAV, AIFF, MP3 (via JUCE AudioFormatManager)

**Loading strategy:**
- Background thread loading (non-blocking UI and audio thread)
- Load entire sample into RAM (no streaming, low-latency playback)
- Atomic swap to audio thread when loading completes

**JUCE classes:**
- `juce::AudioFormatManager` - Format detection and registration
- `juce::AudioFormatReader` - Audio file reading into buffer
- `juce::File` - File path management and drag-drop handling
- `juce::FileChooser` - System file picker for browse button

**Thread safety:**
- File I/O operations run on background thread (via `std::async` or `juce::Thread`)
- Communication with audio thread via `std::atomic<AudioBuffer<float>*>` pointer swap
- Audio thread never blocks on file operations
- Double-buffering: Load to temp buffer → atomic swap → delete old buffer on message thread

**Error handling:**
- Missing files on restore: Clear sample, show "No Sample Loaded" in UI
- Invalid formats: Show error message in UI, don't crash
- Read failures: Fallback to empty buffer (silent playback)

**Sample rate conversion:**
- If loaded sample rate ≠ plugin sample rate, resample during load using `juce::ResamplingAudioSource`
- Convert to plugin's sample rate before atomic swap (no resampling in audio thread)

---

### MIDI Routing

**Input handling:** Receives MIDI from DAW host OR computer keyboard (see Keyboard-to-MIDI system below)

**Note mapping:**
- Full MIDI range: 0-127 (C-2 to G8)
- Root note: MIDI 60 (C3) plays sample at original pitch
- All notes trigger same sample (single-sample POC)
- No velocity layers (velocity only affects volume)
- Omni mode (responds to all MIDI channels)

**JUCE classes:**
- `juce::MidiBuffer` - MIDI event storage in processBlock
- `juce::MidiMessage` - Individual MIDI message parsing
- `juce::Synthesiser::renderNextBlock()` - Handles MIDI note-on/off internally

**Processing:**
- MIDI messages processed in `processBlock()` on audio thread
- Note-on triggers: Voice allocation, sample playback from start
- Note-off handling: Immediate voice release (no envelope in POC)
- No CC handling (no MIDI learn in POC)

**Example note triggering:**
```cpp
// Synthesiser handles this internally via renderNextBlock
for (const auto metadata : midiMessages)
{
    auto message = metadata.getMessage();
    if (message.isNoteOn())
    {
        int note = message.getNoteNumber();  // 0-127
        int velocity = message.getVelocity();  // 0-127
        synthesiser.noteOn(1, note, velocity / 127.0f);
    }
    else if (message.isNoteOff())
    {
        synthesiser.noteOff(1, note, 0.0f, true);
    }
}
```

---

### Keyboard-to-MIDI System

**Purpose:** Allow computer keyboard input to trigger sampler notes (for testing without MIDI controller)

**Default keymap:** Major scale (baseNote: MIDI 36/C2, intervals [0,2,4,5,7,9,11])

**JUCE classes:**
- `juce::KeyPress` - Keyboard event detection in UI
- `juce::MidiMessage::noteOn()` / `noteOff()` - MIDI message generation
- `juce::MidiBuffer::addEvent()` - Inject keyboard-generated MIDI into processBlock

**Key layout structure:**
- Bottom row (Z to Slash): C3-G4 (MIDI 48-64, major scale notes)
- 2nd row (A to Backslash): One octave up
- 3rd row (Q to BracketRight): Two octaves up
- Top row (Digit1 to Equal): Three octaves up
- Numpad: Alternative layout

**Key examples (major scale mapping):**
- KeyZ → MIDI 48 (C3)
- KeyX → MIDI 50 (D3)
- KeyC → MIDI 52 (E3)
- KeyV → MIDI 53 (F3)
- KeyQ → MIDI 60 (C4)
- Comma → MIDI 60 (C4, alternative)

**Implementation flow:**
1. UI thread: Detect `keyPressed()` event on PluginEditor
2. UI thread: Map key → MIDI note number using major scale intervals
3. UI thread: Create `MidiMessage::noteOn(channel, note, velocity)`
4. UI thread → Audio thread: Add MIDI message to lock-free queue
5. Audio thread: In `processBlock()`, drain queue → inject into MidiBuffer
6. Audio thread: Synthesiser processes injected MIDI messages normally

**Thread safety:**
- Keyboard events handled on UI/message thread
- MIDI messages passed via lock-free queue (`juce::AbstractFifo` or atomic queue)
- Audio thread reads from queue without blocking UI thread

**Future expansion (post-POC):**
- UI dropdown to select keymap: Major, Minor, Pentatonic, Chromatic
- Customizable base note (currently hardcoded to C2/MIDI 36)
- Octave shift keys (currently implicit in row layout)

**Reference implementation:**
- Path: `/Users/kristinnroachgunnarsson/Desktop/Dev/sampler-monorepo/packages/audio-components/src/shared/keyboard/keyboard-keymaps.ts`
- Contains: Major scale intervals, keymap layouts, base note configuration

---

### State Persistence

**What state is saved:**
- APVTS parameters: `volume`, `tuning` (automatic)
- Custom state: Currently loaded sample file path

**Serialization format:**
- APVTS parameters: Automatic via `AudioProcessorValueTreeState`
- Custom state: ValueTree with structure:
  ```xml
  <PluginState>
    <Sample path="/path/to/loaded/sample.wav" />
  </PluginState>
  ```

**JUCE classes:**
- `juce::AudioProcessorValueTreeState` - Parameter persistence (automatic)
- `juce::ValueTree` - Custom state tree for sample path
- `juce::XmlElement` - XML serialization for custom state

**Save/restore methods:**
- `getStateInformation(MemoryBlock& destData)` - Serialize APVTS + sample path
- `setStateInformation(const void* data, int sizeInBytes)` - Deserialize, trigger background load

**Restore behavior:**
- Sample path doesn't exist: Show "Sample not found" in UI, leave slot empty
- Invalid data: Use defaults (volume 0.75, tuning 0.0, no sample)
- Version migration: Not needed for POC (future: check version tag)

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| volume | Float | 0.0-1.0 | Velocity-Sensitive Volume | Linear gain multiplier, combined with MIDI velocity |
| tuning | Float | -12.0 to +12.0 semitones | Pitch-Shifting Engine | Pitch offset from root note (C3), affects playback rate calculation |

---

## Algorithm Details

### Pitch Calculation

**Algorithm:** Exponential frequency scaling from semitone offset

**Implementation notes:**
- Formula: `playbackRate = pow(2.0, semitoneOffset / 12.0)`
- Semitone offset: `semitoneOffset = (midiNote - 60) + tuningParameter`
- Example calculations:
  - MIDI 60 (C3) + tuning 0.0 → 0 semitones → 1.0x rate (original pitch)
  - MIDI 72 (C4) + tuning 0.0 → +12 semitones → 2.0x rate (1 octave up)
  - MIDI 48 (C2) + tuning 0.0 → -12 semitones → 0.5x rate (1 octave down)
  - MIDI 60 (C3) + tuning +12.0 → +12 semitones → 2.0x rate (1 octave up)
  - MIDI 60 (C3) + tuning -12.0 → -12 semitones → 0.5x rate (1 octave down)
- Pre-calculate playback rate once per note-on (not per sample)

### Linear Interpolation

**Algorithm:** Weighted average of adjacent samples

**Implementation notes:**
- Formula: `output = sample[i] * (1 - frac) + sample[i+1] * frac`
- Where: `i = floor(playbackPosition)`, `frac = playbackPosition - i`
- Bounds checking: If `i+1 >= sampleLength`, clamp to last sample (one-shot, no loop)
- Trade-off: Fast (~5 CPU cycles) but lower quality (audible artifacts at extreme transposition)
- Future upgrade: Lagrange3rd or sinc interpolation for higher quality

### Voice Stealing

**Algorithm:** Oldest-first voice stealing

**Implementation notes:**
- Track `startTime` for each voice (sample-accurate timestamp)
- When all 16 voices active and note-on received:
  1. Scan all 16 voices for oldest `startTime`
  2. Call `stopNote()` on oldest voice (immediate release)
  3. Allocate oldest voice to new note
- No crossfade during stealing (abrupt stop, acceptable for POC)
- Alternative algorithms considered: Lowest-note-first, quietest-voice-first (rejected for simplicity)

---

## Integration Points

### Feature Dependencies

- **Sample loading → Sample playback:** Must load sample into memory before playback can occur
- **File I/O → Thread safety:** Background loading must complete atomic swap before audio thread accesses buffer
- **MIDI input → Voice allocation:** MIDI note-on must trigger voice allocation before sample playback
- **Keyboard input → MIDI routing:** Keyboard events must generate MIDI messages before synthesiser processes them
- **Pitch calculation → Interpolation:** Playback rate must be calculated before fractional sample reading
- **Voice allocation → Voice stealing:** When all voices active, stealing must complete before new voice starts

---

### Parameter Interactions

- **Volume × MIDI velocity:** Both multiplicatively combined for final gain
  - Formula: `finalGain = volumeParameter * (velocity / 127.0)`
  - Volume at 0.75, velocity 100 → finalGain = 0.75 * (100/127) = 0.59
  - Allows independent control: Volume sets overall level, velocity provides performance dynamics

- **Tuning + MIDI note:** Both added to calculate semitone offset
  - Formula: `semitoneOffset = (midiNote - 60) + tuningParameter`
  - Example: MIDI 65 (F3) + tuning -5.0 → 5 + (-5) = 0 semitones → plays at original pitch
  - Allows creative transposition: Set tuning to -7 to play major scale sample as minor

- **Sample rate independence:** Tuning and pitch are sample-rate-agnostic (exponential scaling)
  - Playback rate formula works at any sample rate (48kHz, 96kHz, 192kHz)
  - Sample loaded at different rate is resampled during load (not in audio thread)

---

### Processing Order Requirements

**Sequential processing order (REQUIRED):**

1. **MIDI input received:** Host delivers MIDI buffer to `processBlock()`
   - Must happen first (host-controlled timing)

2. **Keyboard MIDI injection:** Drain keyboard event queue → inject into MIDI buffer
   - Before synthesiser processing so keyboard notes are treated same as external MIDI

3. **Synthesiser rendering:** Call `synthesiser.renderNextBlock()`
   - Internally handles: MIDI parsing, voice allocation, note-on/off, sample rendering
   - Produces audio output in buffer

4. **Output routing:** Audio buffer passed to host
   - Final step, no post-processing in POC

**Why order matters:**
- Keyboard injection before synthesiser: Ensures keyboard-generated MIDI is processed same frame
- MIDI processing before rendering: Note-on must allocate voice before samples are rendered
- Sample loading is asynchronous: Happens on background thread, atomic swap can occur anytime (not in processBlock critical path)

---

### Thread Boundaries

**Threads:**
- **Audio thread:** Real-time processing in `processBlock()` - NO allocations, NO locks, NO file I/O
- **Message thread:** UI interactions, parameter changes, button clicks, keyboard events
- **Background thread:** File loading, sample buffer allocation, format reading

**Communication mechanisms:**
- **APVTS parameters:** Atomic reads (audio thread) / atomic writes (message thread) - handled by JUCE
- **Sample buffer pointer:** `std::atomic<AudioBuffer<float>*>` - lock-free swap
- **Keyboard MIDI queue:** Lock-free queue (`juce::AbstractFifo`) - UI thread writes, audio thread reads
- **File load completion flag:** `std::atomic<bool>` - background thread sets, message thread polls

**Audio thread operations:**
- Read current sample buffer pointer (atomic load)
- Read volume/tuning parameters via APVTS `getRawParameterValue()->load()`
- Drain keyboard MIDI queue (lock-free pop)
- Render all active voices into output buffer
- NO sample loading, NO file I/O, NO mutex locks

**Message thread operations:**
- Handle drag-drop file events
- Launch background file loading thread
- Poll file load completion flag
- Atomic swap of sample buffer pointer when load completes
- Handle keyboard key press/release events
- Push MIDI messages to keyboard queue (lock-free)

**Background thread operations:**
- Open file via `AudioFormatReader`
- Allocate new `AudioBuffer<float>`
- Read entire file into buffer
- Resample if sample rate mismatch
- Set load completion flag (atomic)
- Hand off buffer to message thread for atomic swap

**Safety guarantees:**
- Audio thread NEVER waits on file I/O
- Audio thread only reads from pre-loaded buffer (no locks)
- Background thread NEVER touches sample buffer in use by audio thread
- Double-buffering for sample loading: Load to temp → atomic swap → delete old on message thread
- Keyboard queue bounded size (drop events if full, prevent unbounded growth)

---

## Implementation Risks

### Sample Playback Engine

**Complexity:** MEDIUM
- JUCE Synthesiser class provides infrastructure (voice allocation, MIDI handling)
- Custom SynthesiserVoice implementation required (sample playback logic)
- Custom SynthesiserSound implementation required (sample storage, MIDI range)

**Risk Level:** LOW

**Risk factors:**
1. First-time JUCE Synthesiser usage (learning curve for API)
2. Voice lifecycle management (IDLE → ACTIVE → RELEASING states)
3. Sample bounds checking (prevent reading beyond buffer end)

**Alternative approaches:**
1. **Manual voice management:**
   - Complexity: HIGH
   - Skip JUCE Synthesiser, implement custom polyphony system
   - Best for: When JUCE Synthesiser limitations found
   - Rejected: Reinventing wheel, higher risk than using proven JUCE class

2. **Single voice (monophonic):**
   - Complexity: LOW
   - Only one sample plays at a time, simpler architecture
   - Best for: Initial prototype to validate concept
   - Rejected: Doesn't meet POC requirements (polyphony is core feature)

**Fallback architecture:**
- **Primary:** 16-voice polyphonic via JUCE Synthesiser
- **Fallback 1:** If Synthesiser proves too complex → 8 voices (still polyphonic)
- **Fallback 2:** If voice stealing causes glitches → No stealing, drop notes when all voices active
- **Fallback 3:** If polyphony fundamentally broken → Single voice monophonic (reduced scope)

**Mitigation strategy:**
1. Study JUCE synthesiser tutorial: https://juce.com/tutorials/tutorial_synth_using_midi_input/
2. Reference existing JUCE sampler examples (SimpleSynth example in JUCE)
3. Implement voice allocation first, test with sine wave before adding sample playback
4. Unit test voice stealing edge cases (all 16 voices active, rapid note-on)
5. Incremental development: Monophonic → Polyphonic → Voice stealing

---

### Thread-Safe Sample Loading

**Complexity:** MEDIUM
- Background thread loading is straightforward (std::async or juce::Thread)
- Atomic pointer swap requires careful ordering
- Double-buffering to prevent audio thread from accessing deleted buffer

**Risk Level:** MEDIUM

**Risk factors:**
1. Race condition: Audio thread reading old buffer while message thread deletes it
2. Memory leak: Forgetting to delete old buffer after swap
3. Null pointer dereference: Audio thread accessing buffer before first load
4. ABA problem: Atomic swap assumes buffer address uniqueness

**Alternative approaches:**
1. **Shared pointer with atomic swap:**
   - Complexity: MEDIUM
   - Use `std::shared_ptr<AudioBuffer>` with atomic operations
   - Automatic memory management (no manual delete)
   - Best for: Reducing memory leak risk
   - Trade-off: Slight overhead from reference counting (acceptable)

2. **Mutex-protected buffer access:**
   - Complexity: LOW
   - Lock mutex in audio thread before reading buffer
   - Best for: Simplest thread safety
   - Rejected: Mutex in audio thread is real-time violation, can cause glitches

3. **Triple-buffering:**
   - Complexity: HIGH
   - Three buffers: One for audio thread, one for loading, one for swap
   - Best for: Eliminating all blocking
   - Rejected: Overkill for single-sample POC, adds complexity

**Fallback architecture:**
- **Primary:** Atomic pointer swap with manual memory management
- **Fallback 1:** If atomic swap causes issues → `std::shared_ptr` with atomic (simpler memory management)
- **Fallback 2:** If threading proves too complex → Load on message thread, accept brief audio glitch during load
- **Fallback 3:** If all thread safety fails → Require plugin reload after sample change (reduced UX)

**Mitigation strategy:**
1. Study JUCE thread safety patterns in documentation
2. Use `std::atomic<AudioBuffer<float>*>` from start (proven pattern)
3. Implement deletion on message thread only (never on audio thread)
4. Add nullptr checks in audio thread before dereferencing buffer
5. Test with rapid file loading (stress test atomic swap)
6. Valgrind or AddressSanitizer to detect memory leaks/race conditions

---

### Computer Keyboard to MIDI Mapping

**Complexity:** MEDIUM
- Keyboard event detection is straightforward (juce::Component::keyPressed)
- Major scale intervals simple (array lookup: [0,2,4,5,7,9,11])
- Lock-free queue for MIDI messages requires care

**Risk Level:** LOW-MEDIUM

**Risk factors:**
1. Lock-free queue complexity (push from UI, pop from audio thread)
2. Keyboard focus issues (editor must have focus to receive key events)
3. Key repeat events (holding key triggers multiple note-ons)
4. MIDI message timing (injected at buffer boundary, not sample-accurate)

**Alternative approaches:**
1. **JUCE MidiKeyboardComponent:**
   - Complexity: LOW
   - Built-in JUCE component for on-screen piano keyboard
   - Best for: Avoiding custom keyboard mapping
   - Rejected: Doesn't match creative brief (computer keyboard, not on-screen piano)

2. **Simple atomic flags per key:**
   - Complexity: LOW
   - Array of `std::atomic<bool>` for each key, polled in processBlock
   - Best for: Avoiding lock-free queue
   - Trade-off: Less responsive (can miss rapid key presses), simpler implementation

3. **Direct MIDI injection without queue:**
   - Complexity: LOW
   - Directly add to MidiBuffer in processBlock (no queue)
   - Problem: Requires thread-safe MidiBuffer access or mutex (real-time violation)
   - Rejected: MidiBuffer not thread-safe for concurrent writes

**Fallback architecture:**
- **Primary:** Lock-free queue (juce::AbstractFifo) for MIDI messages
- **Fallback 1:** If queue causes issues → Atomic boolean array (polling approach)
- **Fallback 2:** If keyboard focus unreliable → Standalone-only feature (disable in DAW plugins)
- **Fallback 3:** If all approaches fail → Remove keyboard mapping (MIDI controller required)

**Mitigation strategy:**
1. Use `juce::AbstractFifo` (JUCE's lock-free FIFO, battle-tested)
2. Bound queue size (e.g., 128 messages max) to prevent unbounded growth
3. Set `setWantsKeyboardFocus(true)` on editor component
4. Detect key repeat: Ignore note-on if same key already active
5. Test with rapid typing, sustain pedal simulation (hold keys)
6. Reference implementation: `/Users/kristinnroachgunnarsson/Desktop/Dev/sampler-monorepo/packages/audio-components/src/shared/keyboard/keyboard-keymaps.ts`

---

### Pitch-Shifting via Playback Rate

**Complexity:** LOW
- Mathematical formula is simple: `pow(2.0, semitones / 12.0)`
- Linear interpolation is straightforward
- No FFT, no phase vocoder, no granular synthesis

**Risk Level:** LOW

**Risk factors:**
1. Audible artifacts at extreme transposition (±2 octaves)
   - Linear interpolation quality degrades far from root note
2. Aliasing when pitch-shifting up (high-frequency content folds over Nyquist)
3. Sample bounds checking during interpolation (prevent buffer overrun)

**Alternative approaches:**
1. **Higher-quality interpolation (Lagrange, sinc):**
   - Complexity: MEDIUM
   - Better quality, especially at extreme transposition
   - CPU cost: ~3-5x higher than linear
   - Best for: Future upgrade post-POC
   - When to use: If linear interpolation artifacts unacceptable

2. **Granular synthesis:**
   - Complexity: HIGH
   - Time-domain pitch shifting with grains (overlap-add)
   - Best for: Better quality than playback rate, worse than phase vocoder
   - Rejected: Overkill for POC, higher complexity than needed

3. **Phase vocoder:**
   - Complexity: VERY HIGH
   - FFT-based pitch shifting, highest quality
   - CPU cost: ~40-60% single core
   - Rejected: Not needed for POC, extreme overkill for simple sampler

**Fallback architecture:**
- **Primary:** Linear interpolation (fast, acceptable for POC)
- **Fallback 1:** If artifacts unacceptable → Limit transposition range to ±1 octave (MIDI 48-72)
- **Fallback 2:** If still unacceptable → Implement Lagrange3rd interpolation
- **Fallback 3:** Last resort → Switch to granular synthesis (major architecture change)

**Mitigation strategy:**
1. Implement linear interpolation first (prove concept works)
2. Test with various sample types (drums, sustained tones, speech)
3. Document acceptable transposition range in user manual (±2 octaves typical)
4. Add note in UI: "For best quality, load samples close to desired pitch"
5. Benchmark CPU usage (linear interpolation should be <5% single core)

---

### Overall Project Risk

**Overall complexity:** MEDIUM
- Multiple systems: Synthesiser + File I/O + Keyboard mapping + Thread safety
- Each system is MEDIUM complexity individually
- Integration points require careful coordination

**Highest risk component:** Thread-Safe Sample Loading
- Represents ~40% of project risk
- Most error-prone (race conditions, memory leaks)
- Critical for UX (sample loading must not glitch audio)
- Requires deep understanding of atomics and memory ordering

**Recommended approach:**
1. **Phase 1 - Validate concept:** Implement basic synthesiser with hardcoded sample (NO file loading)
   - Prove JUCE Synthesiser works, voice allocation correct, MIDI routing functional
   - LOW risk, quick validation
2. **Phase 2 - Add file loading:** Implement thread-safe sample loading with atomic swap
   - MEDIUM risk, most critical system
   - Test thoroughly before proceeding
3. **Phase 3 - Add keyboard mapping:** Implement computer keyboard to MIDI
   - MEDIUM risk, but isolated from other systems
   - Can be disabled if problematic (fallback: MIDI controller required)
4. **Phase 4 - Polish:** Tune interpolation quality, optimize CPU, improve UX
   - LOW risk, refinement phase

---

## Architecture Decisions

### JUCE Synthesiser vs Custom Voice Management

**Decision:** Use JUCE Synthesiser class for voice allocation and polyphony

**Rationale:**
- Industry-standard JUCE class, battle-tested in thousands of plugins
- Handles MIDI note-on/off parsing automatically
- Provides voice allocation, voice stealing, polyphony out-of-box
- Reduces implementation complexity vs. custom voice management
- Well-documented with tutorials and examples

**Alternatives considered:**
1. **Custom voice management:**
   - Why rejected: Reinventing wheel, higher risk of bugs, more code to maintain
   - When to reconsider: If JUCE Synthesiser limitations found (unlikely for simple sampler)

2. **Third-party sampler library:**
   - Why rejected: Adds external dependency, licensing complexity, not JUCE-native
   - When to reconsider: If JUCE Synthesiser fundamentally insufficient

**Tradeoffs accepted:**
- **Learning curve:** Must learn JUCE Synthesiser API (SynthesiserVoice, SynthesiserSound abstractions)
  - Acceptable because: API is well-documented, tutorials available, reusable knowledge for future plugins
- **Less control:** JUCE manages voice allocation internally (can't customize algorithm easily)
  - Acceptable because: Default oldest-first stealing is industry standard, POC doesn't need custom algorithms
- **Abstraction overhead:** Slight performance cost vs. raw C++ implementation
  - Acceptable because: Overhead is negligible (<1% CPU), clarity and maintainability worth it

**When to revisit:**
- If voice stealing algorithm needs customization (e.g., lowest-note-first)
- If JUCE Synthesiser causes unexpected bugs or limitations
- If performance profiling shows Synthesiser overhead is significant (unlikely)

---

### Linear Interpolation vs Higher-Quality Resampling

**Decision:** Use linear interpolation for pitch-shifting in POC

**Rationale:**
- Simplest implementation (2-point weighted average)
- Fast (~5 CPU cycles per sample)
- Acceptable quality for moderate transposition (±1 octave)
- POC goal is learning and validation, not production quality
- Easy upgrade path to Lagrange/sinc post-POC

**Alternatives considered:**
1. **Lagrange interpolation (4-point or 8-point):**
   - Why rejected: Higher complexity, 3-5x CPU cost, overkill for POC
   - When to reconsider: If linear artifacts are unacceptable in testing

2. **Sinc interpolation (bandlimited):**
   - Why rejected: Highest quality but 10-20x CPU cost, requires windowed sinc lookup tables
   - When to reconsider: For production version if targeting professional users

3. **No interpolation (nearest neighbor):**
   - Why rejected: Extremely low quality (zipper noise, aliasing), unusable even for POC
   - When to reconsider: Never (unacceptable quality)

**Tradeoffs accepted:**
- **Audible artifacts at extreme transposition:** Aliasing when pitch-shifting up >2 octaves, muddy sound when shifting down >2 octaves
  - Acceptable because: POC targets moderate use cases, users can load samples at appropriate pitch
  - Mitigation: Document recommended transposition range (±1-2 octaves) in manual
- **Lower quality than professional samplers:** Kontakt, Battery use high-quality resampling
  - Acceptable because: POC is learning project, not competing with commercial samplers
  - Upgrade path: Replace linear with Lagrange post-POC (isolated change in renderNextBlock)

**When to revisit:**
- If testing reveals linear interpolation is unacceptable even for POC
- If users complain about quality (post-POC testing)
- When upgrading to production version (implement Lagrange3rd as default)

---

### Atomic Pointer Swap vs Shared Pointer for Sample Loading

**Decision:** Use raw atomic pointer swap (`std::atomic<AudioBuffer<float>*>`) with manual memory management

**Rationale:**
- Proven pattern in real-time audio applications
- Zero overhead in audio thread (simple atomic load)
- Explicit control over memory lifetime (delete on message thread)
- No reference counting overhead
- Matches JUCE threading best practices

**Alternatives considered:**
1. **Shared pointer with atomic operations:**
   - Why rejected: Reference counting adds overhead (atomic increment/decrement on every access)
   - When to reconsider: If manual memory management causes leaks or bugs (use as fallback)

2. **Mutex-protected buffer access:**
   - Why rejected: Mutex in audio thread is real-time violation, can cause glitches
   - When to reconsider: Never for audio thread (acceptable only for message thread)

3. **Triple-buffering (read/write/swap):**
   - Why rejected: Overkill for single-sample POC, adds complexity without benefit
   - When to reconsider: If atomic swap proves insufficient (unlikely)

**Tradeoffs accepted:**
- **Manual memory management:** Must carefully delete old buffer on message thread
  - Risk: Memory leak if delete forgotten, dangling pointer if deleted too early
  - Mitigation: Code review, Valgrind/AddressSanitizer testing, clear ownership rules
- **No automatic safety:** Raw pointers don't prevent null dereference or use-after-free
  - Mitigation: Nullptr checks in audio thread, atomic ordering guarantees, testing

**When to revisit:**
- If atomic pointer swap causes race conditions or memory leaks in testing
- If manual memory management proves too error-prone (switch to shared_ptr)
- If Valgrind reports memory safety issues (consider RAII wrappers)

---

### Computer Keyboard Mapping: Lock-Free Queue vs Atomic Flags

**Decision:** Use lock-free queue (`juce::AbstractFifo`) for keyboard-to-MIDI messages

**Rationale:**
- Allows sample-accurate MIDI injection (messages timestamped)
- Bounded queue size prevents unbounded growth
- `juce::AbstractFifo` is battle-tested, lock-free, JUCE-native
- Supports rapid key presses (queue buffers bursts)
- Clean separation: UI thread produces, audio thread consumes

**Alternatives considered:**
1. **Atomic boolean array (polling):**
   - Why rejected: Not sample-accurate, can miss rapid key presses, less responsive
   - When to reconsider: If lock-free queue proves too complex (simpler fallback)

2. **Direct MidiBuffer injection:**
   - Why rejected: MidiBuffer not thread-safe for concurrent writes, requires mutex (real-time violation)
   - When to reconsider: Never (thread-unsafe)

3. **Built-in JUCE MidiKeyboardComponent:**
   - Why rejected: On-screen piano keyboard, not computer keyboard mapping
   - When to reconsider: If custom keyboard mapping fails (doesn't match creative brief)

**Tradeoffs accepted:**
- **Lock-free queue complexity:** Requires understanding FIFO read/write indices, wraparound logic
  - Acceptable because: `juce::AbstractFifo` abstracts complexity, well-documented
- **Bounded queue size:** If queue fills (user types >128 notes faster than consumed), drop events
  - Acceptable because: Extremely unlikely scenario (would require superhuman typing speed)
  - Mitigation: 128-message queue is generous buffer, drop oldest messages if full
- **Not sample-accurate within buffer:** Messages injected at buffer boundary, not exact sample position
  - Acceptable because: Buffer size typically 64-512 samples (~1-10ms), imperceptible latency
  - Professional samplers also inject at buffer boundaries

**When to revisit:**
- If lock-free queue causes bugs or complexity issues (fall back to atomic flags)
- If keyboard focus proves unreliable (disable feature in plugin, Standalone-only)
- If users report dropped notes (increase queue size or optimize consumption)

---

## Special Considerations

### Thread Safety

- All parameter reads use atomic `getRawParameterValue()->load()` (APVTS provides this)
- Sample buffer pointer accessed via `std::atomic<AudioBuffer<float>*>::load(std::memory_order_acquire)`
- Memory ordering: Acquire load in audio thread, release store in message thread (prevents reordering)
- Keyboard MIDI queue uses `juce::AbstractFifo` (lock-free, single-producer/single-consumer)
- No mutex locks in audio thread (real-time safe)
- Voice state (playback position, note, velocity) is per-voice (no shared state between voices)

### Performance

- **Synthesiser overhead:** ~1-2% CPU (JUCE voice allocation is efficient)
- **Linear interpolation:** ~5 CPU cycles per sample per voice
- **Pitch calculation:** Once per note-on (negligible, not per-sample)
- **Total estimated:** ~5-10% single core at 48kHz with 16 voices active
  - Breakdown: 16 voices × linear interpolation × sample rendering
  - Acceptable for POC (leaves headroom for future envelope, filters, effects)
- **Optimization opportunities:**
  - SIMD for sample rendering (future)
  - Pre-calculate pitch ratios for common MIDI notes (lookup table)
  - Optimize voice stealing (skip inactive voices in scan)

### Denormal Protection

- Use `juce::ScopedNoDenormals` in `processBlock()` (flushes denormals to zero)
- Sample playback doesn't generate denormals (audio data is typically non-zero)
- Tuning parameter cannot produce denormals (exponential function always returns normal floats)
- Volume parameter at 0.0 produces silence (zeros, not denormals)

### Sample Rate Handling

- Sample loaded at different rate is resampled during background load (using `juce::ResamplingAudioSource`)
- Playback rate calculation is sample-rate-agnostic (exponential scaling)
- `prepareToPlay()`: Initialize Synthesiser with sample rate, allocate voice buffers
- No sample-rate-dependent coefficients (no filters in POC)
- Supports all common sample rates: 44.1kHz, 48kHz, 88.2kHz, 96kHz, 192kHz

### Latency

- Zero processing latency (one-shot sample playback, no lookahead)
- Do NOT report latency via `getLatencySamples()` (returns 0)
- Keyboard-to-MIDI latency: ~1-10ms (buffer boundary injection)
- File loading latency: Asynchronous, doesn't block playback

---

## Research References

### Professional Plugins

1. **Native Instruments Kontakt**
   - 256-note polyphony, 16-part multitimbrality
   - Voice stealing with fade-out of oldest note
   - Scripting language for custom polyphony limits per key
   - Observation: Industry standard for sampler architecture

2. **Native Instruments Battery**
   - Focused on drum sampling with 128 voices (16 polyphony per pad)
   - Sample layering interface, per-note routing
   - Observation: Simpler than Kontakt, closer to SimpleSampler scope

3. **DirectWave Sampler**
   - 128-note polyphony, 16-part layering
   - Mod matrix, multi-sample support
   - Observation: Similar polyphony count to SimpleSampler (16 voices)

### JUCE Documentation

- **juce::Synthesiser** - Built-in polyphonic synthesiser with voice allocation
  - URL: https://docs.juce.com/master/classSynthesiser.html
  - Key finding: `addVoice()` and `addSound()` setup, `renderNextBlock()` for processing
- **juce::SynthesiserVoice** - Voice implementation base class
  - URL: https://docs.juce.com/master/classSynthesiserVoice.html
  - Key finding: Override `renderNextBlock()`, `startNote()`, `stopNote()` for custom playback
- **juce::SynthesiserSound** - Sound description base class
  - URL: https://docs.juce.com/master/classSynthesiserSound.html
  - Key finding: Reference-counted, shared between Synthesiser objects
- **juce::AudioFormatManager** - Format detection and reading
  - URL: https://docs.juce.com/master/classAudioFormatManager.html
  - Key finding: `registerBasicFormats()` adds WAV/AIFF, `createReaderFor()` for file loading
- **juce::MidiKeyboardComponent** - Computer keyboard to MIDI
  - URL: https://docs.juce.com/master/classMidiKeyboardComponent.html
  - Key finding: Built-in QWERTY mapping, customizable key-to-note mapping

### Technical Resources

- **JUCE Tutorial: Build a MIDI synthesiser**
  - URL: https://juce.com/tutorials/tutorial_synth_using_midi_input/
  - Reference for Synthesiser class usage, voice implementation
- **JUCE Tutorial: Playing sound files**
  - URL: https://juce.com/tutorials/tutorial_playing_sound_files/
  - Reference for AudioFormatManager, thread-safe file loading
- **Pitch Shifting via Sample-Rate Conversion (Moeller Studios)**
  - URL: https://www.moellerstudios.org/pitch-shifting-via-sample-rate-conversion/
  - Reference for playback rate pitch shifting, interpolation quality
- **Computer Keyboard MIDI Mapping (sampler-monorepo reference)**
  - Path: `/Users/kristinnroachgunnarsson/Desktop/Dev/sampler-monorepo/packages/audio-components/src/shared/keyboard/keyboard-keymaps.ts`
  - Reference for major scale intervals, keymap layouts

---

## Notes

- POC intentionally minimal: Single sample, no looping, no ADSR envelope, no filters
- Future expansion planned: Sample trimming, looping, pre-processing pipeline, performance effects
- Root note C3 (MIDI 60) chosen as middle of keyboard (standard sampler convention)
- 16-voice polyphony matches professional samplers (DirectWave, Battery per-pad)
- Linear interpolation acceptable for POC, upgrade to Lagrange post-testing
- Computer keyboard mapping uses major scale (most musical for testing)
- Thread safety is highest priority (prevent audio glitches during sample loading)

### Sources

Professional Samplers Research:
- [Native Instruments Kontakt Review - Sound on Sound](https://www.soundonsound.com/reviews/native-instruments-kontakt)
- [6 Best Sampler Plugins 2025 - Integr Audio](https://integraudio.com/6-best-sampler-plugins/)
- [How to make a 3 voices polyphony per key script in Kontakt - KVR Audio](https://www.kvraudio.com/forum/viewtopic.php?t=463943)

Pitch Shifting Research:
- [Pitch Shifting via Sample-Rate Conversion - Moeller Studios](https://www.moellerstudios.org/pitch-shifting-via-sample-rate-conversion/)
- [Question regarding proper method of real time pitch shifting - KVR Audio](https://www.kvraudio.com/forum/viewtopic.php?t=529132)

Keyboard to MIDI Research:
- [Midiano - Interactive Piano Learning App](https://midiano.com/)
- [Virtual MIDI Piano Keyboard - VMPK](https://vmpk.sourceforge.io/)
- [Ableton Live: Computer Keyboard as MIDI Controller - Sonic Bloom](https://sonicbloom.net/ableton-live-tutorial-computer-keyboard-as-midi-controller/)

JUCE Documentation:
- [JUCE: Synthesiser Class Reference](https://docs.juce.com/master/classSynthesiser.html)
- [JUCE: SynthesiserVoice Class Reference](https://docs.juce.com/master/classSynthesiserVoice.html)
- [Build a MIDI synthesiser - JUCE Tutorial](https://juce.com/tutorials/tutorial_synth_using_midi_input/)
- [JUCE: AudioFormatManager Class Reference](https://docs.juce.com/master/classAudioFormatManager.html)
- [Build an audio player - JUCE Tutorial](https://juce.com/tutorials/tutorial_playing_sound_files/)
- [JUCE: MidiKeyboardComponent Class Reference](https://docs.juce.com/master/classMidiKeyboardComponent.html)
